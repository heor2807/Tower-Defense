package Entity.Moveable.Enemy;import Entity.AbstractEntity;import core.GameField;import javafx.scene.image.Image;import java.util.Stack;/*|===========================================================================================================||   Extend from GameEntity, this is interface of all Enemy, contain properties like HP, speed, armor, price ||===========================================================================================================| */public abstract class Enemy extends AbstractEntity {    private double speed;    private long armor, health, reward;    private Image img;    private Direction direction;    private Stack<Direction> directionStack;    public enum Direction {        LEFT, RIGHT, UP, DOWN;    }    public Enemy(double posX, double posY, double witdth, double height){        super(posX, posY, witdth, height);    }    public Enemy(double speed, long armor, long health, long reward){        super();        this.speed = speed;        this.armor = armor;        this.health = health;        this.reward = reward;//        this.img = img;    }    public Enemy(double posX, double posY, double width, double height, double speed, long armor, long health, long reward){        super(posX, posY, width, height);        this.speed = speed;        this.armor = armor;        this.health = health;        this.reward = reward;//        this.img = img;    }    public void setInfo(double speed, long armor, long health, long reward) {        setSpeed(speed);        setArmor(armor);        setHealth(health);        setReward(reward);        setImg(img);    }    public Direction getDirection() {        return direction;    }    public double getSpeed() {        return speed;    }    public long getArmor() {        return armor;    }    public long getHealth() {        return health;    }    public long getReward() {        return reward;    }    public void setDirection(Direction direction) {        this.direction = direction;    }    public Image getImg() {        return img;    }    public void setHealth(long health) {        this.health = health;    }    public void setSpeed(double speed) {        this.speed = speed;    }    public void setReward(long reward) {        this.reward = reward;    }    public void setArmor(long armor) {        this.armor = armor;    }    public void setImg(Image img) {        this.img = img;    }    public void addDirection(Direction direction) {        directionStack.push(direction);    }    public Direction peekDirection(){        return directionStack.peek();    }    public void changeDirection() {        switch (peekDirection()){            case RIGHT://                setDirection();            case LEFT:            case DOWN:            case UP:        }    }    public void findDirection(){    }    public int getNextRoadValue(){        double index = getPosY();        double jndex = getPosX();        if(index%1==0 && jndex%1==0){            switch (getDirection()){                case UP:                    return GameField.getRoadInfo().getRoadInfo((int)index, (int)jndex-1);                case DOWN:                    return GameField.getRoadInfo().getRoadInfo((int)index, (int)jndex+1);                case LEFT:                    return GameField.getRoadInfo().getRoadInfo((int)index-1, (int)jndex);                case RIGHT:                    return GameField.getRoadInfo().getRoadInfo((int)index+1, (int)jndex);            }        }        return 0;    }    public static double evaluateDistance (){        //to-do: calculate the distance between bullet and enemy?        return 0;    }    public void update(){        //update new status of the enemy    }    public final boolean onAttack(){        //check if the enemy is under attack        return true;    }    public static void doAttack(){        //harm the enemy    }    public final boolean isDestroyed(){        //check if the enemy meet the condition to die :3        return true;    }    public static void doDestroy(){        //if it must die already, then destroy it    }}